<!DOCTYPE html>
<html>
    <head>
        <!-- 헤더 (link,style) -->
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&family=Orbit&display=swap" rel="stylesheet">
<style>
    /* 전체 설정 */
    * {
        font-size: 1.2rem;
    }
    body {
        overflow-x: hidden;
    }
    hr {
        opacity: initial;
    }
    p {
        margin-bottom: 0;
    }
    /* 블로그 화면 중앙에 표시 */
    .blog-contents-center {
        width: 1000px;
        margin: 0 auto;
        height: 100%;
        position: relative;
    }
    @media (max-width:992px){ /* 화면너비 ~lg 기준 */
        .blog-contents-center {
            width: 100vw;
        }
    }
    /* 상단바 설정 */
    #container_topbar {
        position: fixed;
        top: 0;
        width: 100vw;
        height: 3rem;
        background-color: #FFFFFF;
        box-shadow: 0px 1px 20px 1px rgba(0,0,0,0.25);
        z-index: 100;
    }
    /* 하단 컨텐츠 설정 */
    #container_contents {
        width: 100vw;
        min-height: calc(100vh - 3rem);
    }
    #container_contents::before {
        content: "";
        width: 100%;
        height: 100%;
        position: fixed;
        background-image: url("/assets/img/background.jpg");
        background-size: 100vw;
        filter: opacity(0.8);
    }
    /* 리스트 설정 */
    #container_list {
        padding-left: 0;
        padding-right: 1rem;
    }
    @media (max-width:992px){ /* 화면너비 ~lg 기준 */
        #container_list {
            padding-left: 1rem;
            padding-right: 1rem;
        }
    }
    #list {
        background-color: #FFFFFF;
        box-shadow: 1px 1px 20px 1px rgba(0,0,0,0.25);
        border-radius: .25rem;
    }
    #list img {
        display: none;
    }
    /* 포스트 설정 */
    #container_post {
        padding-left: 0;
        padding-right: 1rem;
    }
    @media (max-width:992px){ /* 화면너비 ~lg 기준 */
        #container_post {
            padding-left: 1rem;
            padding-right: 1rem;
        }
    }
    #post {
        background-color: #FFFFFF;
        box-shadow: 1px 1px 20px 1px rgba(0,0,0,0.25);
        border-radius: .25rem;
    }
    /* 사이드바 설정 */
    #container_sidebar {
        background-color: #FFFFFF;
        box-shadow: 1px 1px 20px 1px rgba(0,0,0,0.25);
        height: fit-content;
        border-radius: .25rem;
    }
    @media (max-width:992px){ /* 화면너비 ~lg 기준 */
        #container_sidebar {
            position: fixed;
            z-index: 200;
            top: 0;
            height: 100%;
            margin: 0!important;
            transition: transform 0.2s ease-in-out;
            transform: translateX(100%);
        }
        .sidebar-open {
            transform: translateX(0%)!important;
        }
    }
    /* 리스트에서 사용할 스타일 */
    .category-name {
        font-size: 1.4rem;
        font-family: 'Orbit', sans-serif;
        font-weight: bold;
        color: #85C1E9;
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
    .category-list-size {
        font-family: 'Orbit', sans-serif;
        color: #BBB;
        font-size: 0.8rem;
        justify-self: end;
        align-self: end;
    }
    .post-list-item:hover {
        font-weight: bold;
        background-color: #F3F3F3;
        border-radius: 0.25rem;
        cursor: pointer;
    }
    .post-list-no-item {
        font-size: 1rem;
        font-family: 'Gowun Dodum', sans-serif;
        color: #666;
        text-align: center;
    }
    .post-list-border {
        border: 1px dashed #BBB;
        margin: 0.5rem 0rem;
    }
    .post-list-subject {
        font-size: 1rem;
        font-family: 'Gowun Dodum', sans-serif;
        color: #666;
        overflow: hidden;
        max-height: 3em;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }
    .post-list-excerpt {
        font-size: 0.8rem;
        font-family: 'Gowun Dodum', sans-serif;
        color: #BBB;
        overflow: hidden;
        line-height: 1.25;
        max-height: 3.6em;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
    }
    .post-list-excerpt * {
        font-size: 0.8rem;
        font-family: 'Gowun Dodum', sans-serif;
        color: #BBB;
        overflow: hidden;
        line-height: 1.25;
        max-height: 3.6em;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
    }
    .post-list-footer {
        line-height: 0.8;
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
    .post-list-footer * {
        font-size: 0.6rem;
        font-family: 'Orbit', sans-serif;
        line-height: 1;
    }
    .post-list-category {
        color: #3498DB;
    }
    .post-list-uploadtime {
        justify-self: flex-end;
    }
    /* 페이지 버튼에서 사용할 스타일 */
    .page-container {
        text-align: center;
    }
    .page-container .page-button {
        border: 0;
        background-color: white;
        font-size: 1rem;
        color: black;
    }
    .page-container .page-button i {
        font-size: 0.7rem;
    }
    .page-container .page-button.curpage {
        color: #3498DB;
        cursor: default;
    }
    .page-container .page-button.disabled {
        color: #BBB;
        cursor: default;
    }
    /* 포스트에서 사용할 스타일 */
    #post .post-d-none {
        display: none;
    }
    #post * {
        word-break: break-all;
    }
    .post-subject {
        font-size: 1.2rem;
        font-family: 'Orbit', sans-serif;
        font-weight: bold;
        color: #85C1E9;
    }
    .post-border {
        border: 1px dashed #BBB;
        margin: 0.5rem 0rem;
    }
    .post-subtitle {
        line-height: 0.8;
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
    .post-subtitle * {
        font-size: 0.7rem;
        font-family: 'Orbit', sans-serif;
        line-height: 1;
    }
    .post-category {
        color: #3498DB;
    }
    .post-uploadtime {
        justify-self: flex-end;
    }
    .post-contents {
        font-family: 'Gowun Dodum', sans-serif;
    }
    .post-contents * {
        font-size: 0.9rem;
    }
    .post-contents img {
        max-width: 100%;
    }
    /* 포스트 게시글 내 문서 스타일 */
    .post-chapter {
        background-color: #85C1E9;
        font-size: 1rem;
        font-weight: bold;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
    }
    .post-chapter-collapse {
        width: 100%;
        border: 0;  
    }
    .post-chapter-collapse:hover {
        background-color: #3498DB;
        cursor: pointer;
        color: white;
    }
    .post-chapter-collapse i{
        transition: transform 0.2s ease-in-out;
        transform: rotate(0deg);
    }
    .post-chapter-collapse.collapsed i{
        transform: rotate(180deg);
    }
    .post-code {
        font-family: 'Orbit', sans-serif;
        color: black;
        background-color: #F3F3F3;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        overflow-x: auto;
    }
    .post-overegg {
        font-size: 0.7rem;
        color: #AAA;
    }
    .post-table {
        width: 100%;
    }
    .post-table * {
        border: 1px solid #aaa;
        padding: 0px 0.25rem;
    }
    /* 사이드바 프로필에서 사용할 스타일 */
    #sidebar_profile {
        overflow-x: hidden;
    }
    #sidebar_profile:hover {
        font-weight: bold;
        background-color: #F3F3F3;
        border-radius: 0.25rem;
        cursor: pointer;
    }
    .sidebar-profile-logo {
        border: 1px solid #AAA;
        padding: 4px 0px;
    }
    .sidebar-profile-item {
        font-family: 'Orbit', sans-serif;
        font-size: 0.7rem;
        white-space: nowrap;
    }
    .sidebar-profile-icon {
        min-width: 10px;
        display: inline-block;
        text-align: center;
        line-height: 0.6;
    }
    .sidebar-profile-icon i {
        color: #3498DB;
        font-size: 0.7rem;
    }
    /* 사이드바 카테고리에서 사용할 스타일 */
    .sidebar-category-border-bold {
        border: 1px dashed #000;
        margin: 0.25rem 0rem;
    }
    .sidebar-category-border-light {
        border: 1px dashed #BBB;
        margin: 0.5rem 0rem;
    }
    .sidebar-category-item {
        font-family: 'Gowun Dodum', sans-serif;
        font-size: 1rem;
        color: #666;
        line-height: 1.9;
        padding-left: 0.5rem;
    }
    .sidebar-category-item:hover {
        font-weight: bold;
        background-color: #F3F3F3;
        border-radius: 0.25rem;
        cursor: pointer;
    }
    .sidebar-category-size {
        font-family: 'Orbit', sans-serif;
        font-size: 0.7rem;
        color: #3498DB;
    }
    .sidebar-category-icon {
        min-width: 10px;
        display: inline-block;
        text-align: center;
        line-height: 0.6;
    }
    .sidebar-category-icon i {
        color: #3498DB;
        position: relative;
        top: -4px;
        font-size: 0.5rem;
    }
</style>
<link rel="shortcut icon" href="/assets/img/favicon.svg"/>

<title>Lizzy on Python</title>

    </head>
    <body>
        <div>
            <!-- 상단바 -->
            <div id="container_topbar">
    <div class="blog-contents-center px-3 py-2" style="display: grid; grid-template-columns: 1fr 1fr;">
        <!-- 블로그 로고 -->
        <span>
            <img src="/assets/logo/logo_dark.png" onclick="location.href = '/';" style="height: 42px; position: relative; bottom: 2px; left: -14px; cursor: pointer; filter: opacity(0.9);"/>
        </span>
        <!-- PC버전 -->
        <span class="container_search d-none d-lg-block" style="justify-self: flex-end;">
            <!--i class="fa-solid fa-magnifying-glass align-middle"></i-->
        </span>
        <!-- 모바일 사이드바 오픈 아이콘 -->
        <span id="btn_sidebar_open" class="d-block d-lg-none" style="justify-self: flex-end;">
            <i class="fa-solid fa-bars align-middle"></i>
        </span>
    </div>
</div>
            <!-- 컨텐츠 -->
            <div id="container_contents">
                <div class="blog-contents-center" style="padding-top: 3rem;">
                    <div class="row m-0">
                        <!-- 리스트 -->
                        <div id="container_list" class="col-12 col-lg-9 my-3">
                            <div id="list" class="px-3 py-2">

    <!-- 포스트 카테고리명 -->
    <div class="category-name">
        All
        <span class="category-list-size">총 24건</span>
    </div>
    <hr class="post-list-border">
    <!-- 포스트 리스트 -->
    
    <div class="post-list-item px-2" onclick="location.href = '/blog/20241204/blog_00005';">
        <div class="post-list-subject">2024-12-04 블로그 스킨 변경하기</div>
        <div class="post-list-excerpt mt-1"><img src="/assets/img/blog_00005_001.png" style="width: 40rem;" /><br />
봄에 분홍색 테마로 만들었던 것 같은데, 1년을 썼더니 눈이 너무 익숙해졌다.<br />
겨울을 맞이해서 좀 파랗게 바꿔보기로 했다..<br />
<br />
<img src="/assets/img/blog_00005_002.png" style="width: 40rem;" /><br />
뒷배경과 전체적인 테마 컬러를 파란색으로 변경하고<br />
심심한 사이드바에 AI 그림을 추가했다.<br />
예쁘고 레트로한 그림을 단순히 블로그 꾸미기의 일환으로 집어넣은건데..<br />
꼭 프로필 처럼 보인다..<br />
<br />
써놓은 글이 꽤 있는데 업로드를 못하고 있다.<br />
좀 부지런하게 살아야지 ..<br />
</div>
        <div class="post-list-footer mt-2 py-1">
            <span class="post-list-category">blog</span>
            <span class="post-list-uploadtime">2024-12-04 17:22</span>
        </div>
    </div>
    <hr class="post-list-border">
    
    <div class="post-list-item px-2" onclick="location.href = '/spring/20241204/spring_00001';">
        <div class="post-list-subject">DTO, VO, Entity in Layered Architecture</div>
        <div class="post-list-excerpt mt-1">스프링을 사용하기 위해 프로젝트를 만들고 가장 먼저 고민하던 것이 “뭐부터 만들어서 어디에 집어넣어야 하지?..” 였다.<br />
Django에서는 Model-Template-View 였고 스프링은 Model-View-Controller니까 하나씩 만들면 되나?<br />
라고 생각하며 예제를 보는데, Controller는 뭐고 DTO는 또 뭐지 싶었다.<br />
<br />
이제 Controller,Repository,Entity는 잘 쓰겠고 DTO도 알겠는데 VO는 굳이 왜 있어야 하나 싶어서 알아봤다.<br />
<br />
<div class="post-chapter">1. DTO, VO, Entity</div>
<br />
<br />
<table class="post-table">
    <tbody>
        <tr>
            <th></th>
            <th>DTO</th>
            <th>VO</th>
            <th>Entity</th>
        </tr>
        <tr>
            <td>의미</td>
            <td>Data Transfer Object</td>
            <td>Value Object</td>
            <td></td>
        </tr>
        <tr>
            <td>역할</td>
            <td>계층 간 데이터 전달</td>
            <td>도메인 내에서 특정 값의 무결성과 의미를 표현</td>
            <td>데이터베이스와 매핑, 영속성 관리</td>
        </tr>
        <tr>
            <td>사용처</td>
            <td>Controller ↔ Service ↔ Repository 간 데이터 교환</td>
            <td>Service 계층 및 도메인 로직 처리</td>
            <td>Repository 계층 및 DB 연동</td>
        </tr>
        <tr>
            <td>목적</td>
            <td>외부 입력/출력 데이터를 캡슐화 (Request/Response)</td>
            <td>비즈니스 로직에서 값 검증 및 불변성 보장</td>
            <td>데이터 저장 및 영속성 관리, DB 테이블과 매핑</td>
        </tr>
        <tr>
            <td>불변성</td>
            <td>일반적으로 가변적 (Setter를 통해 변경 가능)</td>
            <td>불변 객체로 설계</td>
            <td>가변적 (JPA가 상태를 관리)</td>
        </tr>
        <tr>
            <td>검증 책임</td>
            <td>데이터의 기본적인 형식 검증</td>
            <td>값의 고유성과 비즈니스 규칙 검증</td>
            <td>검증 책임 없음 (최대한 단순화)</td>
        </tr>
        <tr>
            <td>비교</td>
            <td>참조로 비교 (equals/hashCode 구현 잘 안 함)</td>
            <td>값 자체를 기준으로 비교 (equals/hashCode 구현)</td>
            <td>참조 및 값 비교 둘다 (주로 식별자 기반 비교)</td>
        </tr>
        <tr>
            <td>테스트</td>
            <td>외부 데이터와의 통신을 테스트하기에 적합</td>
            <td>도메인 로직의 독립적인 테스트 가능</td>
            <td>DB와 연동된 테스트에 적합</td>
        </tr>
        <tr>
            <td>주 내용</td>
            <td>클라이언트 요청/응답에 필요한 최소한의 데이터</td>
            <td>특정 의미를 갖는 단일 값 또는 관련 값들의 묶음</td>
            <td>전체 엔티티 데이터 및 상태 관리</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<div class="post-chapter">2. 이메일 등록 예제</div>
<br />
<div class="post-code" style="font-size: 0.8rem;">
// DTO<br />
public class UserRequestDTO {<br />
&nbsp;&nbsp;private String email;<br />
&nbsp;&nbsp;private String name;<br />
<br />
&nbsp;&nbsp;// Getter, Setter<br />
}<br />
<br />
// VO<br />
public class Email {<br />
&nbsp;&nbsp;private final String value;<br />
<br />
&nbsp;&nbsp;public Email(String value) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;if (!value.matches("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException("Invalid email format");<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;this.value = value;<br />
&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;public String getValue() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;return value;<br />
&nbsp;&nbsp;}<br />
}<br />
<br />
// Entity<br />
@Entity<br />
public class UserEntity {<br />
&nbsp;&nbsp;@Id<br />
&nbsp;&nbsp;@GeneratedValue<br />
&nbsp;&nbsp;private Long id;<br />
&nbsp;&nbsp;private String email;<br />
&nbsp;&nbsp;private String name;<br />
<br />
&nbsp;&nbsp;// Constructor for JPA<br />
&nbsp;&nbsp;public UserEntity() {}<br />
<br />
&nbsp;&nbsp;public UserEntity(String email, String name) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;this.email = email;<br />
&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br />
&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;// Getter<br />
}<br />
<br />
// Service<br />
@Service<br />
public class UserService {<br />
&nbsp;&nbsp;public void registerUser(UserRequestDTO dto) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;// DTO → VO<br />
&nbsp;&nbsp;&nbsp;&nbsp;Email email = new Email(dto.getEmail());<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;// VO → Entity<br />
&nbsp;&nbsp;&nbsp;&nbsp;UserEntity entity = new UserEntity(email.getValue(), dto.getName());<br />
&nbsp;&nbsp;&nbsp;&nbsp;userRepository.save(entity);<br />
&nbsp;&nbsp;}<br />
}<br />
</div>
<br />
<br />
<div class="post-chapter">3. 정리</div>
<br />
<ul>
  <li>DTO → VO → Entity 흐름은 도메인 로직이 있는 경우 적용<br />
  - VO로 데이터의 무결성을 검증하고 비즈니스 로직을 처리<br />
  - Entity는 단순히 데이터를 저장하고 관리<br /></li>
  <li>DTO → Entity는 단순 CRUD 작업처럼 도메인 로직이 필요하지 않은 경우에 적용<br />
  - 항상 VO가 필요하진 않은 듯<br />
<br /></li>
</ul>
<div class="post-chapter">출처</div>
<br />
<span class="post-overegg" style="color: blue; border: 0;">출처는 챗GPT</span><br />
</div>
        <div class="post-list-footer mt-2 py-1">
            <span class="post-list-category">spring</span>
            <span class="post-list-uploadtime">2024-12-04 11:07</span>
        </div>
    </div>
    <hr class="post-list-border">
    
    <div class="post-list-item px-2" onclick="location.href = '/security/20241014/security_00002';">
        <div class="post-list-subject">x86-64 Register</div>
        <div class="post-list-excerpt mt-1">예전에는 어떤 순서로 공부하면 좋을지 잘 몰랐는데<br />
요새는 좋은 공부 사이트들이 많아서 공부에 더 의욕이 생긴다!<br />
<br />
<div class="post-chapter">0. 개요</div>
<br />
x86-64 CPU 아키텍쳐의 레지스터에 대해 정리한 내용이다.<br />
<br />
<div class="post-chapter">1. 레지스터</div>
<br />
<ul>
  <li>레지스터는 프로세서 내에서 자료를 보관하는 기억 장소이다.<br /></li>
  <li>현재 계산 수행중인 값을 저장하는 데 사용된다.<br /></li>
  <li>범용 레지스터, 인덱스 레지스터, 포인터 레지스터, 세그먼트 레지스터, 플래그 레지스터 등으로 분류할 수 있다.<br />
<br /></li>
</ul>
<div class="post-chapter">2. 범용 레지스터</div>
<br />
<ul>
  <li>범용 레지스터는 다목적 레지스터로, 관례적으로 사용되는 용도는 있으나 개발자의 의도나 규약(시스템 콜 등)에 따라 다르게 사용할 수 있다.<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th>이름</th>
            <th>의미</th>
            <th>용도</th>
            <th>비고</th>
        </tr>
        <tr>
            <td>EAX</td>
            <td>Accumulator Register</td>
            <td>산술,논리 연산을 담당하는 레지스터로, 함수의 반환값을 저장한다.</td>
            <td>RAX(64bit): 확장된 EAX로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;EAX(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;AX(16bit): EAX의 하위 16bit를 가리킨다.&lt;/br&gt;AH(8bit): AX의 상위(High) 8bit를 가리킨다.&lt;/br&gt;AL(8bit): AX의 하위(Low) 8bit를 가리킨다.</td>
        </tr>
        <tr>
            <td>EBX</td>
            <td>Base Register</td>
            <td>메모리 주소 저장 또는 배열 접근을 위한 기준 포인터로 사용된다.</td>
            <td>RBX(64bit): 확장된 EBX로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;EBX(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;BX(16bit): EBX의 하위 16bit를 가리킨다.&lt;/br&gt;BH(8bit): BX의 상위(High) 8bit를 가리킨다.&lt;/br&gt;BL(8bit): BX의 하위(Low) 8bit를 가리킨다.</td>
        </tr>
        <tr>
            <td>ECX</td>
            <td>Count Register</td>
            <td>반복 작업에서 카운트 역할을 위해 사용된다.</td>
            <td>RCX(64bit): 확장된 ECX로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;ECX(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;CX(16bit): ECX의 하위 16bit를 가리킨다.&lt;/br&gt;CH(8bit): CX의 상위(High) 8bit를 가리킨다.&lt;/br&gt;CL(8bit): CX의 하위(Low) 8bit를 가리킨다.</td>
        </tr>
        <tr>
            <td>EDX</td>
            <td>Data Register</td>
            <td>큰 수를 연산할때 사용된다. </td>
            <td>RDX(64bit): 확장된 EDX로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;EDX(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;DX(16bit): EDX의 하위 16bit를 가리킨다.&lt;/br&gt;DH(8bit): DX의 상위(High) 8bit를 가리킨다.&lt;/br&gt;DL(8bit): DX의 하위(Low) 8bit를 가리킨다.</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<div class="post-chapter">3. 인덱스 레지스터</div>
<br />
<ul>
  <li>인덱스 레지스터는 메모리의 데이터 접근 및 조작을 위한 레지스터이다.<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th>이름</th>
            <th>의미</th>
            <th>용도</th>
            <th>비고</th>
        </tr>
        <tr>
            <td>ESI</td>
            <td>Source Index</td>
            <td>데이터 복사, 문자열 연산, 입출력 등 작업에서 소스 데이터의 주소를 가리키는 데 사용된다. </td>
            <td>RSI(64bit): 확장된 ESI로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;ESI(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;SI(16bit): ESI의 하위 16bit를 가리킨다.</td>
        </tr>
        <tr>
            <td>EDI</td>
            <td>Destination Index</td>
            <td>데이터 복사, 문자열 연산, 입출력 등 작업에서 목적지 데이터의 주소를 가리키는 데 사용된다.</td>
            <td>RDI(64bit): 확장된 EDI로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;EDI(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;DI(16bit): EDI의 하위 16bit를 가리킨다.</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<div class="post-chapter">4. 포인터 레지스터</div>
<br />
<ul>
  <li>포인터 레지스터는 스택 및 프로그램의 실행 흐름 관리를 위한 레지스터로, 메모리 주소를 저장한다.<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th>이름</th>
            <th>의미</th>
            <th>용도</th>
            <th>비고</th>
        </tr>
        <tr>
            <td>ESP</td>
            <td>Stack Pointer</td>
            <td>현재 스택의 최상단 주소를 저장하는 데 사용된다.</td>
            <td>RSP(64bit): 확장된 ESP로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;ESP(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;SP(16bit): ESP의 하위 16bit를 가리킨다.</td>
        </tr>
        <tr>
            <td>EBP</td>
            <td>Base Pointer</td>
            <td>현재 스택의 하단 주소를 저장하는 데 사용된다.</td>
            <td>RBP(64bit): 확장된 EBP로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;EBP(32bit): 32bit 아키텍처에서 사용된다.&lt;/br&gt;BP(16bit): ESP의 하위 16bit를 가리킨다.</td>
        </tr>
        <tr>
            <td>EIP</td>
            <td>Instruction Pointer</td>
            <td>다음에 실행할 명령의 메모리 주소를 저장하는 데 사용된다.</td>
            <td>RIP(64bit): 확장된 EIP로, 64bit 아키텍처에서 사용된다.&lt;/br&gt;EIP(32bit): 32bit 아키텍처에서 사용된다.</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<div class="post-chapter">5. 세그먼트 레지스터</div>
<br />
<ul>
  <li>메모리의 각 세그먼트에 대한 기준 주소를 저장하기 위한 레지스터이다.<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th>이름</th>
            <th>의미</th>
            <th>용도</th>
        </tr>
        <tr>
            <td>CS</td>
            <td>Code Segment</td>
            <td>코드 세그먼트의 주소를 저장하는 데 사용된다.</td>
        </tr>
        <tr>
            <td>DS</td>
            <td>Data Segment</td>
            <td>데이터 세그먼트의 주소를 저장하는 데 사용된다.</td>
        </tr>
        <tr>
            <td>SS</td>
            <td>Stack Segment</td>
            <td>스택 세그먼트의 주소를 저장하는 데 사용된다.</td>
        </tr>
        <tr>
            <td>ES</td>
            <td></td>
            <td>추가적인 데이터 세그먼트 레지스터로 EDI 레지스터와 함께 문자열 연산에서 사용된다. </td>
        </tr>
        <tr>
            <td>FS</td>
            <td></td>
            <td>여분의 데이터 세그먼트 레지스터이다.</td>
        </tr>
        <tr>
            <td>GS</td>
            <td></td>
            <td>여분의 데이터 세그먼트 레지스터이다.</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<div class="post-chapter">6. 플래그 레지스터</div>
<br />
<ul>
  <li>각 비트가 연산의 결과를 나타내는 플래그로 사용되는 레지스터이다. 상태 플래그, 컨트롤 플래그 등으로 분류된다.<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th>분류</th>
            <th>이름</th>
            <th>의미</th>
            <th>용도</th>
        </tr>
        <tr>
            <td>상태 플래그</td>
            <td>ZF</td>
            <td>Zero Flag</td>
            <td>연산 결과가 0일 경우 1로 설정된다. &lt;/br&gt;(*JZ 또는 JNZ 명령어에서 사용)</td>
        </tr>
        <tr>
            <td>상태 플래그</td>
            <td>SF</td>
            <td>Sign Flag</td>
            <td>연산 결과가 음수일 경우 1로 설정된다.</td>
        </tr>
        <tr>
            <td>상태 플래그</td>
            <td>CF</td>
            <td>Carry Flag</td>
            <td>부호 없는 수의 오버플로우가 발생한 경우 1로 설정된다.</td>
        </tr>
        <tr>
            <td>상태 플래그</td>
            <td>OF</td>
            <td>Overflow Flag</td>
            <td>부호 있는 수의 오버플로우가 발생한 경우 1로 설정된다.</td>
        </tr>
        <tr>
            <td>상태 플래그</td>
            <td>PF</td>
            <td>Parity Flag</td>
            <td>연산 결과에 1인 bit가 짝수개이면 1로 설정된다.</td>
        </tr>
        <tr>
            <td>상태 플래그</td>
            <td>AF</td>
            <td>Auxiliary Flag</td>
            <td>연산 결과 하위 4bit에 부호 없는 오버플로우가 발생한 경우 1로 설정된다.</td>
        </tr>
        <tr>
            <td>컨트롤 플래그</td>
            <td>TF</td>
            <td>Trap Flag</td>
            <td>1로 설정하면 디버거의 attach가 가능한 상태가 된다.</td>
        </tr>
        <tr>
            <td>컨트롤 플래그</td>
            <td>IF</td>
            <td>Interrupt Flag</td>
            <td>1로 설정하면 외부 인터럽트 요구를 무시한다.</td>
        </tr>
        <tr>
            <td>컨트롤 플래그</td>
            <td>DF</td>
            <td>Direction Flag</td>
            <td>문자열 등 작업에서 처리 방향을 제어하기 위해 사용된다.</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<div class="post-chapter">출처</div>
<br />
<span class="post-overegg" style="color: blue; border: 0;">
    https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0
</span><br />
<span class="post-overegg" style="color: blue; border: 0;">
    https://haekt-log.tistory.com/93
</span><br />
</div>
        <div class="post-list-footer mt-2 py-1">
            <span class="post-list-category">security</span>
            <span class="post-list-uploadtime">2024-10-14 11:14</span>
        </div>
    </div>
    <hr class="post-list-border">
    
    <div class="post-list-item px-2" onclick="location.href = '/security/20240930/security_00001';">
        <div class="post-list-subject">x86-64 Assembly</div>
        <div class="post-list-excerpt mt-1">취미삼아 보안 공부를 다시 시작했는데,<br />
이번 시즌에는 전보다 더 발전된 무언가를 꼭 이뤄냈으면 좋겠다.( ⁎ ᵕᴗᵕ ⁎ )<br />
<br />
<div class="post-chapter">0. 개요</div>
<br />
어셈블리 언어의 기본 개념과 x86-64 ISA의 어셈블리 언어에 대해 정리했다.<br />
<br />
<div class="post-chapter">1. 어셈블리 언어</div>
<br />
<ul>
  <li>어셈블리 언어는 기계어와 1:1 대응이 되는 저수준 언어이다.<br /></li>
  <li>사용자가 기계어를 쉽게 읽을수 있게 하기 위해 만들어졌다.<br /></li>
  <li>레지스터나 메모리에 직접 접근하기 쉽다.<br /></li>
  <li>CPU의 명령어 집합(ISA)에 따라 여러 종류가 존재한다: (IA-32, x86-64, ARM, MIPS)<br /></li>
  <li>CPU 성능이 낮을수록, RAM이 작을수록, 컴파일러보다 인간이 더 최적화를 잘 할수록 유리하다.<br />
<br /></li>
</ul>
<div class="post-chapter">2. x86-64 어셈블리 언어와 문법</div>
<br />
<ul>
  <li>2020년 기준 절반 이상의 CPU가 x86-64 아키텍처를 채택하고 있다.<br /></li>
  <li>두가지 문법을 가지고 있다: Intel, AT&amp;T<br /></li>
  <li>Intel 문법은 주로 Windows에서, AT&amp;T문법은 주로 Unix에서 사용된다.<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th></th>
            <th>Intel</th>
            <th>AT&amp;T</th>
        </tr>
        <tr>
            <td>피연산자 순서</td>
            <td>instr dest, src <br />(dest를 좌측, src를 우측에 표기)</td>
            <td>instr src, dest <br />(src를 좌측, dest를 우측에 표기)</td>
        </tr>
        <tr>
            <td>접두사</td>
            <td>instr reg, 1 <br />(자동으로 파라미터 타입 파악) </td>
            <td>instr $1, %reg <br />(값은 $, 레지스터는 %를 앞에 표시)</td>
        </tr>
        <tr>
            <td>피연산자 크기</td>
            <td>instr reg, 1234 <br />(레지스터를 통해 자동으로 결정)</td>
            <td>instrl $1234, %reg <br />(명령어에 크기를 나타내는 접미사 표시)</td>
        </tr>
        <tr>
            <td>메모리 주소 표기</td>
            <td>instr reg1, [reg2+3] <br />([]로 구분)</td>
            <td>instr 3(%reg2), %reg1 </td>
        </tr>
    </tbody>
</table>
<br />
<div class="post-chapter">3. x86-64 어셈블리 명령어</div>
<br />
<table class="post-table">
    <tbody>
        <tr>
            <th>명령어</th>
            <th>의미</th>
            <th>Intel</th>
        </tr>
        <tr>
            <td>mov</td>
            <td>src에 들어있는 값을 dest에 대입</td>
            <td>mov dest, src</td>
        </tr>
        <tr>
            <td>lea</td>
            <td>src에 들어있는 값(주소)을 dest에 대입<br />(*mov와 다르게 lea는 주소에 대한 연산이 가능)</td>
            <td>lea dest, src</td>
        </tr>
        <tr>
            <td>add</td>
            <td>dest에 src의 값을 더함</td>
            <td>add dest, 3</td>
        </tr>
        <tr>
            <td>sub</td>
            <td>dest에 src의 값을 뺌</td>
            <td>sub dest, 3</td>
        </tr>
        <tr>
            <td>inc</td>
            <td>dest의 값을 1 증가시킴</td>
            <td>inc dest</td>
        </tr>
        <tr>
            <td>dec</td>
            <td>dest의 값을 1 감소시킴</td>
            <td>dec dest</td>
        </tr>
        <tr>
            <td>and</td>
            <td>dest와 src의 각 비트를 AND 연산해서 dest에 저장</td>
            <td>and dest, src</td>
        </tr>
        <tr>
            <td>or</td>
            <td>dest와 src의 각 비트를 OR 연산해서 dest에 저장</td>
            <td>or dest, src</td>
        </tr>
        <tr>
            <td>xor</td>
            <td>dest와 src의 각 비트를 XOR 연산해서 dest에 저장</td>
            <td>xor dest, src</td>
        </tr>
        <tr>
            <td>not</td>
            <td>dest의 각 비트를 반전</td>
            <td>not dest</td>
        </tr>
        <tr>
            <td>cmp</td>
            <td>dest와 src를 비교하고 플래그를 설정, 결과값 대입안함<br />(*dest와 src 비교에 주로 사용)</td>
            <td>cmp dest, src</td>
        </tr>
        <tr>
            <td>test</td>
            <td>dest와 src를 AND연산하고 플래그를 설정, 결과값 대입안함<br />(*dest와 src가 0인지 확인하는데 주로 사용)</td>
            <td>test dest, src</td>
        </tr>
        <tr>
            <td>jmp</td>
            <td>dest를 rip에 대입 <br />(*즉 addr의 명령어를 실행)</td>
            <td>jmp dest</td>
        </tr>
        <tr>
            <td>je</td>
            <td>직전에 비교한 두 피연산자가 같으면 점프 <br />(*jump if equal)</td>
            <td>cmp dest, src; <br />je addr; <br />// if dest == src , <br />// jump to addr</td>
        </tr>
        <tr>
            <td>jg</td>
            <td>직전에 비교한 두 연산자 중 전자가 더 크면 점프 <br />(*jump if greater)</td>
            <td>cmp dest, src; <br />jg addr; <br />// if dest &gt; src , <br />// jump to addr</td>
        </tr>
        <tr>
            <td>push</td>
            <td>스택 끝부분에 값(val) 추가 <br />(*스택이 변경되므로 스택 끝을 가리키는 rsp의 값 변경됨)</td>
            <td>push val</td>
        </tr>
        <tr>
            <td>pop</td>
            <td>스택 끝부분의 값을 꺼내서 dest에 저장 <br />(*스택이 변경되므로 스택 끝을 가리키는 rsp의 값 변경됨)</td>
            <td>pop dest</td>
        </tr>
    </tbody>
</table>
*AT&amp;T 문법의 경우는 dest - src 위치 변경<br />
<br />
<div class="post-chapter">4. x86-64 어셈블리 프로시저</div>
<br />
<ul>
  <li>프로시저는 특정 기능을 수행하는 코드 조각이다.<br /></li>
  <li>프로시저 호출 - 프로시저 실행 - 프로시저에서 반환(원래 실행하던 명령어로 복귀) 순으로 실행된다.<br /></li>
  <li>스택에 원래 실행하려던 명령어 주소를 저장한 다음 프로시저를 호출하고, 반환 시 스택에 저장해둔 명령어 주소를 이용해 복귀한다.<br />
<br /></li>
</ul>
<table class="post-table">
    <tbody>
        <tr>
            <th>명령어</th>
            <th>의미</th>
            <th>문법</th>
            <th>실제 동작</th>
        </tr>
        <tr>
            <td>call</td>
            <td>특정 주소의 명령어 호출</td>
            <td>call addr</td>
            <td>push addr; <br />jmp addr;</td>
        </tr>
        <tr>
            <td>leave</td>
            <td>사용중인 스택 프레임 정리</td>
            <td>leave</td>
            <td>mov rsp, rbp;<br />// 스택의 시작점(RBP 레지스터가 가리키는 값) 으로 <br />// 스택의 끝점(RSP 레지스터가 가리키는 값)을 옮긴다.<br />pop rbp; <br />// 스택에 저장해둔 값을 <br />// 스택의 시작점으로 설정한다.</td>
        </tr>
        <tr>
            <td>ret</td>
            <td>원래 실행하던 명령어로 복귀</td>
            <td>ret</td>
            <td>pop rip; <br />// 스택에 저장해둔 값을 <br />// 다음 명령어(RIP 레지스터가 가리키는 값)로 설정한다.</td>
        </tr>
    </tbody>
</table>
<br />
<div class="post-chapter">출처</div>
<br />
<span class="post-overegg" style="color: blue; border: 0;">
    https://ko.wikipedia.org/wiki/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4
</span><br />
<span class="post-overegg" style="color: blue; border: 0;">
    https://namu.wiki/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4
</span><br />
<span class="post-overegg" style="color: blue; border: 0;">
    https://namu.wiki/w/x86/%EB%AA%85%EB%A0%B9%EC%96%B4%20%EB%AA%A9%EB%A1%9D
</span><br />
</div>
        <div class="post-list-footer mt-2 py-1">
            <span class="post-list-category">security</span>
            <span class="post-list-uploadtime">2024-09-30 09:27</span>
        </div>
    </div>
    <hr class="post-list-border">
    
    <div class="post-list-item px-2" onclick="location.href = '/react/20240712/react_00001';">
        <div class="post-list-subject">React.js 클래스vs함수 그리고 hook</div>
        <div class="post-list-excerpt mt-1">지금으로부터 딱 5년전에 리액트를 사용했었다.<br />
그렇게 깊게+오래 사용한게 아니라서 큰 추억은 없고 약간의 “이거 좋네..”라는 느낌만 남았다.<br />
이제는 업무용으로 쓰고 있는데, 5년 전과 비교하면 지금은 엄청나게 매끄럽게 쓰고있는 중이다.<br />
<br />
그런데 문법이 꽤 다른 것 같다. 예전엔 분명 class 어쩌고.. render.. 같은게 있었는데<br />
지금은 function부터 시작하잖아..? (゜▽゜;)<br />
<br />
<div class="post-chapter">1. 클래스형과 함수형 코드 비교</div>
<br />
다음 내용은 class형으로 작성된 컴포넌트이다. (공식 가이드 참고)
<div class="post-code" style="font-size: 0.8rem;">
class Test extends React.Component {<br />
&nbsp;&nbsp;state = {name: "react"}<br />
&nbsp;&nbsp;onBtnClick = () =&gt; { console.log("button clicked"); };<br />
&nbsp;&nbsp;render() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;return (<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={this.onBtnClick}&gt;{this.state.name}&lt;/button&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;);<br />
&nbsp;&nbsp;}<br />
}<br />
</div>
<br />
<br />
위 내용을 함수형으로 바꿔보면 다음과 같이 쓸 수 있다.
<div class="post-code" style="font-size: 0.8rem;">
function Test(){<br />
&nbsp;&nbsp;const [name, setName] = useState("react")<br />
&nbsp;&nbsp;const onBtnClick = () =&gt; { console.log("button clicked") }<br />
&nbsp;&nbsp;return (<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={onBtnClick}&gt;{name}&lt;/button&gt;<br />
&nbsp;&nbsp;)<br />
}<br />
</div>
<br />
<br />
<div class="post-chapter">2. 공통점: 그래도 배치는 비슷하다</div>
<br />
코드 모양만 보면 거의 비슷하다는 느낌이 든다.<br />
클래스형의 경우 무조건 “class”이고 “component”를 extends 해야하고 render도 있어야하지만<br />
그걸 제외하고 전체적인 모양만 보면<br />
<br />
<img src="/assets/img/react_00001_001.png" style="width: 40rem;" /><br />
state를 정의하는 부분, 사용할 메소드를 정의하는 부분, 결과를 그려내는 부분으로 나눠지고<br />
<br />
약간의 코드 길이의 차이를 제외하면<br /> 
정의한다-&gt;가져온다-&gt;집어넣는다 라는 행위는<br />
크게 달라짐이 없어 보인다.<br />
<br />
<div class="post-chapter">3. 차이점: 생명주기 관리가 심플해졌다</div>
<br />
props의 사용법도 차이점이 있으나,<br />
부모에서 자식으로 값을 넘긴다 / props로 접근한다 라는 큰 틀은<br />
같다고 생각해서 제외했다.<br />
<br />
개발 시 가장 큰 차이점은 생명주기 관리의 차이점인 것 같다.<br />
<br />
기존 클래스형에서는 mount / update / unmount 로 상태변경을 관리했는데<br />
함수형에서는 Hook 으로 일종의 병합이 되어버려서 <br />
(개인적으로는) 기존의 생명주기보다 더 까다로운 접근법을 가지게 되었다는 생각이 든다.<br />
<br />
나는 내가 만드는 대부분의 프로그램이 “처음 로딩될 때” 그리고 “조작했을 때 일부” 변경되기를 바라는데,<br />
Hook은 “날 쳐다봤어? 난 트리거될거야..” 이런 느낌으로 처리가 되어버려서<br />
적응하는데에 시간이 조금 더 필요할 것 같다.<br />
<br />
<div class="post-chapter">4. 근데 결국 함수형으로 가는 수밖에 없다</div>
<br />
그런데 어쩔수없이 함수형으로 가는 수밖에 없을 것 같다.<br />
유용한 대부분의 라이브러리가 Hook을 쓰고 있다고 하니, Hook을 쓰지 않는<br />
class형 컴포넌트로는 대응이 쉽지가 않다고 한다. ⁎′̥̥̥ ㅅ ‵̥̥̥<br />
<br />
리액트 팀은 선택권을 주고싶었겠지만 현실은 늘 차갑다…….
</div>
        <div class="post-list-footer mt-2 py-1">
            <span class="post-list-category">react</span>
            <span class="post-list-uploadtime">2024-07-12 13:17</span>
        </div>
    </div>
    <hr class="post-list-border">
    
    <!-- 페이징 디자인 -->
    <div class="my-3">
        
        <div class="page-container">
            <!-- 이전 -->
            
            <button class="page-button disabled">
                <i class="fa fa-chevron-left"></i>
            </button>
            
            <!-- 페이지 -->
            
                
                <button class="page-button curpage">1</button>
                
            
                
                <button class="page-button" onclick="location.href = '/posts/page/2';">2</button>
                
            
                
                <button class="page-button" onclick="location.href = '/posts/page/3';">3</button>
                
            
                
                <button class="page-button" onclick="location.href = '/posts/page/4';">4</button>
                
            
                
                <button class="page-button" onclick="location.href = '/posts/page/5';">5</button>
                
            
            <!-- 다음 -->
            
            <button class="page-button" onclick="location.href = '/posts/page/2';">
                <i class="fa fa-chevron-right"></i>
            </button>
            
        </div>
        
    </div>
</div>
                        </div>
                        <!-- 사이드바 -->
                        <div id="container_sidebar" class="col-12 col-lg-3 my-3 py-3">
    <!-- 모바일 사이드바 클로즈 아이콘 -->
    <div id="btn_sidebar_close" class="d-block d-lg-none">
        <i class="fa-solid fa-arrow-right align-middle"></i>
    </div>
    <!-- 로고와 프로필 -->
    <div id="sidebar_profile" class="mt-2 p-2" onclick="location.href = '/category/about';">
        <div class="sidebar-profile-logo text-center" style="background-color: white; border: 0;">
            <img src="/assets/img/sidebar_profile.jpg" style="width: 100%;"/>
        </div>
        <div class="mt-2">
            <div class="sidebar-profile-item">
                <span class="sidebar-profile-icon "><i class="fa fa-user"></i></span>
                Lizzy Lee (이지연)
            </div>
            <div class="sidebar-profile-item">
                <span class="sidebar-profile-icon "><i class="fa fa-envelope"></i></span>
                leezy.lee.dev@gmail.com
            </div>
            <div class="sidebar-profile-item">
                <span class="sidebar-profile-icon "><i class="fa fa-comment"></i></span>
                스프링 고수가 될 거야 _〆(´Д⊂
            </div>
        </div>
    </div>
    <!-- 카테고리 리스트 -->
    <div class="mt-2">
        <hr class="sidebar-category-border-bold">
        <div class="sidebar-category-item" data-category="all" style="color: black!important;">
            <span class="sidebar-category-icon"><i class="fa fa-asterisk"></i></span>
            ALL
            <span class="sidebar-category-size">( 24 )</span>
        </div>
        <hr class="sidebar-category-border-bold">
        <!-- 카테고리 : 블로그 -->
            <div class="sidebar-category-item" data-category="blog">
                <span class="sidebar-category-icon"><i class="fa fa-asterisk"></i></span>
                BLOG
                <span class="sidebar-category-size">
                    
                    ( 5 )
                    
                </span>
            </div>
        <!-- 카테고리 : 개념 및 이론 -->
            <div class="sidebar-category-item" data-category="concepts" style="pointer-events: none;">
                <span class="sidebar-category-icon"><i class="fa fa-asterisk"></i></span>
                CONCEPTS
            </div>
        <!-- 카테고리 : 시큐리티(서브) -->
            <div class="sidebar-category-item" data-category="security">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                Security
                <span class="sidebar-category-size">
                    
                    ( 2 )
                    
                </span>
            </div>
        <!-- 카테고리 : 알고리즘(서브) -->
            <div class="sidebar-category-item" data-category="algorithm">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                Algorithm
                <span class="sidebar-category-size">
                    
                    ( 2 )
                    
                </span>
            </div>
        <!-- 카테고리 : 프로그래밍 언어 -->
            <div class="sidebar-category-item" data-category="language" style="pointer-events: none;">
                <span class="sidebar-category-icon"><i class="fa fa-asterisk"></i></span>
                LANGUAGE
            </div>
        <!-- 카테고리 : 파이선(서브) -->
            <div class="sidebar-category-item" data-category="python">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                Python
                <span class="sidebar-category-size">
                    
                    ( 3 )
                    
                </span>
            </div>
        <!-- 카테고리 : 프레임워크 -->
            <div class="sidebar-category-item" data-category="framework" style="pointer-events: none;">
                <span class="sidebar-category-icon"><i class="fa fa-asterisk"></i></span>
                FRAMEWORK
            </div>
        <!-- 카테고리 : 스프링(서브) -->
            <div class="sidebar-category-item" data-category="spring">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                Spring
                <span class="sidebar-category-size">
                    
                    ( 1 )
                    
                </span>
            </div>
        <!-- 카테고리 : 리액트(서브) -->
            <div class="sidebar-category-item" data-category="react">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                React
                <span class="sidebar-category-size">
                    
                    ( 1 )
                    
                </span>
            </div>
        <!-- 카테고리 : 프로젝트 -->
            <div class="sidebar-category-item" data-category="project" style="pointer-events: none;">
                <span class="sidebar-category-icon"><i class="fa fa-asterisk"></i></span>
                PROJECT
            </div>
        <!-- 카테고리 : 넥타리스트(서브) -->
            <div class="sidebar-category-item" data-category="nectarist">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                Nectarist
                <span class="sidebar-category-size">
                    
                    ( 10 )
                    
                </span>
            </div>
        <!-- 카테고리 : 코예(서브) -->
            <div class="sidebar-category-item" data-category="comaid">
                &nbsp;&nbsp;
                <span class="sidebar-category-icon"><i class="fa fa-chevron-right"></i></span>
                CoMaid
                <span class="sidebar-category-size">
                    
                    ( 0 )
                    
                </span>
            </div>
        <!-- -->
        <hr class="sidebar-category-border-bold">
    </div>
</div>
                    </div>
                </div>
            </div>
        </div>
    </body>
    <foot>
        <!-- 푸터 (script) -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
<script src="https://kit.fontawesome.com/a5bdb78e74.js" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-latest.min.js" crossorigin="anonymous"></script>
<script>
    /* 사이드바 토글 */
    $("#btn_sidebar_open").click(function () {
        $("#container_sidebar").addClass("sidebar-open");
        // popstate 이벤트용 더미 스테이트
        console.log("pushstate");
        history.pushState(null, null, null);
    });
    $("#btn_sidebar_close").click(function () {
        // popstate 이벤트를 통해 닫기
        history.back();
    });
    /* 모바일 뒤로가기 이벤트시 사이드바 우선 닫기 */
    $(window).on("popstate", function(e) {
        console.log("popstate");
        if($("#container_sidebar").hasClass("sidebar-open")){
            $("#container_sidebar").removeClass("sidebar-open");
        }
    });
    /* 카테고리 */
    $("#container_sidebar .sidebar-category-item").click(function () {
        var category = $(this).attr("data-category");
        switch(category){
            case "all":
                location.href = "/";
                break;
            case "project":
                break;
            default:
                location.href = "/category/" + category + ".html";
                break;
        }
    });
</script>
    </foot>
</html>